{
    "contents" : "##\n## This code implements PAA and SAX algorithms.\n##\n## changelog:\n##\n## last edited 25-08-2009, seninp@gmail.com\n##\n## v. 0.0\n## 27-02-2009, seninp@gmail.com, created first implementations of PAA & SAX\n##\n##\n## This code is based on the original work of \n## Lin, J., Keogh, E., Lonardi, S. & Chiu, B. \n## which is bearing next copyright:\n##\n\n##\n## THE ORIGINAL COPYRIGHT FROM THE AUTHORS\n##\n##% Copyright and terms of use (DO NOT REMOVE):\n##% The code is made freely available for non-commercial uses only, provided that the copyright \n##% header in each file not be removed, and suitable citation(s) (see below) be made for papers \n##% published based on the code.\n##%\n##% The code is not optimized for speed, and we are not responsible for any errors that might\n##% occur in the code.\n##%\n##% The copyright of the code is retained by the authors.  By downloading/using this code you\n##% agree to all the terms stated above.\n##%\n##%   Lin, J., Keogh, E., Lonardi, S. & Chiu, B. \n##%   \"A Symbolic Representation of Time Series, with Implications for Streaming Algorithms.\" \n##%   In proceedings of the 8th ACM SIGMOD Workshop on Research Issues in Data Mining and \n##%   Knowledge Discovery. San Diego, CA. June 13, 2003. \n##%\n##%\n##%   Lin, J., Keogh, E., Patel, P. & Lonardi, S. \n##%   \"Finding Motifs in Time Series\". In proceedings of the 2nd Workshop on Temporal Data Mining, \n##%   at the 8th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining. \n##%   Edmonton, Alberta, Canada. July 23-26, 2002\n\n\n\n## load matlab library for the 'reshape' function code, why not?\n#\nlibrary(reshape)\n\n## Compute Z normalization for the timeseries.\n##  parameters:\n##  ts - the timeseries to normalize\n##\n##  ts should be a matrix, we do care only about first row\n#\nznorm <- function(ts){\n ts.mean <- mean(ts[1,])\n ts.dev <- sd(ts[1,])\n (ts - ts.mean)/ts.dev\n}\n\n##\n## Compute PAA approximation for the timeseries with reduction\n##  parameters:\n##  ts - timeseries\n##  ap - number of points in approximated timeseries\n#\npaa <- function(ts, ap){\n len <- ncol(ts)\n res <- ts\n if(len != ap){\n  if( (len %% ap) == 0 ){\n   res <- reshape(ts, len %/% ap, ap)\n  }else{\n   tmp <- matrix( rep(0, ap*len), ap, len)\n   for(i in 1:ap){\n    tmp[i, ] <- ts[1, ]\n   }\n   extended <- reshape(tmp, 1, ap*len)\n   res <- reshape(extended, len, ap)\n  }\n }\n matrix(colMeans(res), nrow=1, ncol=ap)\n}\n\n##\n## Converts the specified resolution into the cut points\n##\nalphabet2cut <- function(alphabet_size){\n switch(alphabet_size,\n  0.00,\n  c(-Inf,  0.00),\n  c(-Inf, -0.43,  0.43),\n  c(-Inf, -0.67,  0.00,  0.67),\n  c(-Inf, -0.84, -0.25,  0.25,  0.84),\n  c(-Inf, -0.97, -0.43,  0.00,  0.43,  0.97),\n  c(-Inf, -1.07, -0.57, -0.18,  0.18,  0.57,  1.07),\n  c(-Inf, -1.15, -0.67, -0.32,  0.00,  0.32,  0.67,  1.15),\n  c(-Inf, -1.22, -0.76, -0.43, -0.14,  0.14,  0.43,  0.76,  1.22),\n  c(-Inf, -1.28, -0.84, -0.52, -0.25,  0.00,  0.25,  0.52,  0.84,  1.28),\n  c(-Inf, -1.34, -0.91, -0.60, -0.35, -0.11,  0.11,  0.35,  0.60,  0.91, 1.34),\n  c(-Inf, -1.38, -0.97, -0.67, -0.43, -0.21,  0.00,  0.21,  0.43,  0.67, 0.97, 1.38),\n  c(-Inf, -1.43, -1.02, -0.74, -0.50, -0.29, -0.10,  0.10,  0.29,  0.50, 0.74, 1.02, 1.43),\n  c(-Inf, -1.47, -1.07, -0.79, -0.57, -0.37, -0.18,  0.00,  0.18,  0.37, 0.57, 0.79, 1.07, 1.47),\n  c(-Inf, -1.50, -1.11, -0.84, -0.62, -0.43, -0.25, -0.08,  0.08,  0.25, 0.43, 0.62, 0.84, 1.11, 1.5),\n  c(-Inf, -1.53, -1.15, -0.89, -0.67, -0.49, -0.32, -0.16,  0.00,  0.16, 0.32, 0.49, 0.67, 0.89, 1.15, 1.53),\n  c(-Inf, -1.56, -1.19, -0.93, -0.72, -0.54, -0.38, -0.22, -0.07,  0.07, 0.22, 0.38, 0.54, 0.72, 0.93, 1.19, 1.56),\n  c(-Inf, -1.59, -1.22, -0.97, -0.76, -0.59, -0.43, -0.28, -0.14,  0.00, 0.14, 0.28, 0.43, 0.59, 0.76, 0.97, 1.22, 1.59),\n  c(-Inf, -1.62, -1.25, -1.00, -0.80, -0.63, -0.48, -0.34, -0.20, -0.07, 0.07, 0.20, 0.34, 0.48, 0.63, 0.80, 1.00, 1.25, 1.62),\n  c(-Inf, -1.64, -1.28, -1.04, -0.84, -0.67, -0.52, -0.39, -0.25, -0.13, 0.00, 0.13, 0.25, 0.39, 0.52, 0.67, 0.84, 1.04, 1.28, 1.64),\n )\n}\n\n##\n## compute distance matrix for the alphabet size specified\n##\ndistance_matrix <- function (alphabet_size){\n if(alphabet_size>1 && alphabet_size<20){\n  cutlines <- alphabet2cut(alphabet_size)[2:alphabet_size]\n  distance_matrix <- matrix(rep(0, alphabet_size*alphabet_size), byrow=T, nrow=alphabet_size, ncol=alphabet_size)\n  i=1\n  while(i <= alphabet_size){\n    # the min_dist for adjacent symbols are 0, so we start with i+2\n    j=i+2;\n    while(j <= alphabet_size){\n      # square the distance now for future use\n      distance_matrix[i,j]=(cutlines[i]-cutlines[j-1])*(cutlines[i]-cutlines[j-1])\n      # the distance matrix is symmetric\n      distance_matrix[j,i] = distance_matrix[i,j]\n      j=j+1;\n    }\n    i=i+1;\n  }\n  distance_matrix\n }\n}\n\n##\n## Converts the specified resolution into the cut points\n##\nnum2letter <- function(num){\n  letters <- c(\"a\",  \"b\",  \"c\",  \"d\",  \"e\",\n               \"f\",  \"g\",  \"h\",  \"i\",  \"j\",\n               \"k\",  \"l\",  \"m\",  \"n\",  \"o\",\n               \"p\",  \"q\",  \"r\",  \"s\",  \"t\",\n               \"u\",  \"v\",  \"w\",  \"x\",  \"y\",  \"z\")\n  letters[num]\n}\n\n\n##\n## Converts the timeseries into string\n##\nts2string <- function(ts, aSize){\n cut_points <- alphabet2cut(aSize)\n res <- rep(0, ncol(ts))\n for(i in 1:ncol(ts)){\n  res[i] = length(cut_points[cut_points<=ts[i]])\n }\n num2letter(res)\n}\n\n##\n## compute distance between strings\n##\nmin_dist <- function(str1, str2, alphabet_size, compression_ratio){\n if(length(str1) != length(str2)){\n  stop(\"error: the strings must have equal length\");\n }else{    \n  if(any(str1 > alphabet_size) | any(str2 > alphabet_size)){\n   stop('error: some symbol(s) in the string(s) exceed(s) the alphabet size!');\n  }else{\n    dist_table <- distance_matrix(alphabet_size);\n    dist <- 0;\n    dist = sqrt(compression_ratio * sum(diag(dist_table[str1,str2])));\n  }\n }\n}\n\n##\n## compute the Euclidean distance between the set of points\n##\neuclidean <- function(x, y){\n as.numeric(dist( rbind(x,y) ))\n}\n",
    "created" : 1351605332354.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3088322960",
    "id" : "AA3561A",
    "lastKnownWriteTime" : 1351670126,
    "path" : "/media/Stock/workspace-school/jmotif/RCode/refactor/lib/PAA_SAX.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}